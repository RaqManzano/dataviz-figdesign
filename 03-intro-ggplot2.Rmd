---
title: Data visualisation with tidyverse
---

```{r, echo=FALSE, purl=FALSE, message = FALSE}
source("setup.R")
surveys <- read_csv("data_raw/portal_data_joined.csv")
suppressWarnings(surveys$date <- lubridate::ymd(paste(surveys$year,
                                                     surveys$month,
                                                      surveys$day,
                                                      sep = "-")))
```

<br />

<img src="img/ggplot2.png" width="50"/>

Visualising is probably one of the most satisfying parts of doing data analysis. After all, who doesn't like a nice plot? We have already seen that creating plots with `ggplot()` can be pretty straightforward, because it has a modular way of using tabular data to create the plots.

As a reminder, the basic syntax follows this format:

```
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

and with it, you can easily create plots like this:

```{r ggplot-example, purl = FALSE, eval=TRUE, echo=FALSE}
surveys_complete <- surveys %>% drop_na()

survey_recent <- surveys_complete %>%
                  select(species_id, weight, hindfoot_length, year, sex) %>%
                  filter(year >= 1995)
                  
ggplot(mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point(data = surveys_complete) +
  geom_point(data = survey_recent, colour = "red", alpha = 0.4)
```

## Moving beyond basic plots
Plots creating with `ggplot()` are extremely versatile - you can change any component of the plot, whether it is the data points, the axes, the titles, the ticks on the axes etc. Some of these custom options you will want to use often, whilst others are perhaps less relevant. There are too many options to cover all of them, but we will go through some of the most useful ones.

<br />

### Transparency
Sometimes your data points are really close together, or even overlapping. In these cases we can add some transparency (`alpha`) to avoid over plotting. This is done with the `alpha` argument, which takes values from 0 (100% transparency) to 1 (0% transparency):

```{r adding-transparency, message=FALSE, warning=FALSE, fig.show=TRUE}
ggplot(data = surveys,
       mapping = aes(x = weight, y = hindfoot_length)) +
    geom_point(alpha = 0.2)
```

You can find a list of aesthetics for each type of plot in the [ggplot2 cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf).  

<br />

### Adding colour
We can also add colours for all the points by adding the `colour` argument to the geom.

```{r adding-colours, message=FALSE, warning=FALSE, fig.show=TRUE}
ggplot(data = surveys,
       mapping = aes(x = weight, y = hindfoot_length)) +
    geom_point(colour = "blue")
```

<br />

### Colouring by variable
Another way of colouring data points is **based on a variable**. For example, if we were interested to see which data points belong to each plot type - to see if there is any pattern in the data - then we could give each plot type its own colour. The way to specify this is in the `aes()` helper function, where we give the `colour` argument the relevant variable (i.e. the name of the column in our data set that contains this variable).

```{r adding-colours-data, message=FALSE, warning=FALSE, fig.show=TRUE}
ggplot(data = surveys,
       mapping = aes(x = weight, y = hindfoot_length, colour = plot_type)) +
    geom_point()
```

:::note
**Colour within `aes()` or not?**

It might be a bit confusing where the `colour` argument needs to go. When we were colouring all the data points blue it went in the `geom_point()` and not within an `aes()`, whereas when we were colouring based on `plot_type` it had to go inside the `aes()`. An easy way to remember what to use is: _If the colour is based on the data, then it goes inside `aes()`, otherwise it does not._
:::

## Same data different plots
If we would like to try other type of plots on the data, the best thing is to save the ggplot into a variable as below:

```{r ggplot-assigning, fig.show="hide", message=FALSE, warning=FALSE}
# Assign plot to a variable
surveys_plot <- ggplot(data = surveys, 
                       mapping = aes(x = weight, y = hindfoot_length))

# Draw a scatter plot
surveys_plot + 
    geom_point()
```

As you can see, when we assigned the plot to `surveys_plot` we did not specify a `geom_function`. That is because if we store the plot backbone into a variable, we can then easily add the `geom_function` we are interested in, without having to type all the initial plot data again.

Now let's draw a `geom_smooth` plot.  This plot is good when you need to see if there is any pattern between the two variables being plotted that you would not normally see in a scatter plot due to over plotting.

```{r ggplot-smooth, message=FALSE, warning=FALSE}
surveys_plot +
    geom_smooth()
```

Rather than seeing each plot separately, sometimes plotting multiple plots on top of each other is a better way. You can add multiple plots as layers on top of each other as follows:

```{r ggplot-multiple-layers, message=FALSE, warning=FALSE}
surveys_plot +
  geom_point() +
  geom_smooth()
```

:::note
**Argument inheritance in plots**

- Anything you put in the `ggplot()` function can be seen by any geom layers that you add (_i.e.,_ these are universal plot settings). 
- You can also specify mappings for a given geom independently of the mappings defined globally in the `ggplot()` function.
- The `+` sign used to add new layers must be placed at the end of the line containing the *previous* layer. If, instead, the `+` sign is added at the beginning of the line containing the new layer, >**`ggplot2`** will not add the new layer and will return an error message.

```{r ggplot-layer-syntax, eval=FALSE, purl=FALSE}
# This is the correct syntax for adding layers
surveys_plot +
  geom_point()

# This will not add the new layer and will return an error message
surveys_plot 
  + geom_point()
```
:::

<br />

:::exercise
Scatter plots can be useful exploratory tools for small data sets. For data sets with large numbers of observations, such as the `surveys` data set, over plotting of points can be a limitation of scatter plots. We have already seen how we can visualise data better when we have over-plotting with the `geom_smooth` plot. Another way for handling over-plotting is to display the density of the data through contours. This is handled by the `geom_density` geometry. For this challenge do the following:

1. Create a script called `plot_density2d.R`
2. In this script, load the data from `data_raw/portal_data_joined.csv` into a variable `surveys`.
3. Using `ggplot`, plot the `weight` on the x-axis and `hindfoot_length` on the y-axis in and create a `geom_density2d` plot.

<details><summary>Answer</summary>

```{r ggplot-exercise-density, fig.show="hide", answer=TRUE, message=FALSE, warning=FALSE, purl=FALSE}
library(tidyverse)

# Load the surveys data
surveys <- read_csv("data_raw/portal_data_joined.csv")
 
# Attach data and map x and y axes
surveys_plot <- ggplot(data = surveys, 
                       mapping = aes(x = weight, y = hindfoot_length))
# Draw geom_density2d
surveys_plot +
  geom_density2d()
```
</details>
:::

<br />

## Facets

We have seen that we can highlight parts of our data by using colour. For example, we used `colour = plot_type` to colour our data based by plot type to see if there are any trends in the data.

Another way of highlighting parts of the data is by splitting the data into separate panels, based on a variable within your data. This is called **faceting** and it is a very powerful tool in `ggplot` to better understand your data.

There are two types of facet functions:

* `facet_wrap()` arranges a one-dimensional sequence of panels to fit on one page.
* `facet_grid()` allows you to form a matrix of rows and columns of panels.
Both geometries allow to to specify faceting variables specified with `vars()`.

In general:

* `facet_wrap(facets = vars(facet_variable))`
* `facet_grid(rows = vars(row_variable), cols = vars(col_variable))`.

<br />

### Using `facet_wrap()`
If we wanted to visualise the scatter plot we created above, but split by `plot_type` we would have to use `facet_wrap()`, since we are splitting the data by one variable (`plot_type`):

```{r facet-wrap, warning=FALSE}
ggplot(surveys, 
       aes(x = weight, y = hindfoot_length)) +
  geom_point() +
  facet_wrap(facets = vars(plot_type))
```

<br />

### Using `facet_grid`
What if we wanted to split the data by `plot_type`, but also further divide the data by `sex` to see if there are any clear differences between male and female observations? In that case we would have to split the data based on _two_ variables, which means we have to use `facet_grid()`:

```{r facet-grid, warning=FALSE}
ggplot(surveys, 
       aes(x = weight, y = hindfoot_length)) +
  geom_point() +
  facet_grid(rows = vars(sex), cols = vars(plot_type))
```
  
Finally, with `facet_grid()`, you can organise the panels just by rows or just by columns. Try running this code yourself:

```{r facet-manual, warning=FALSE, eval=FALSE}
# One column, facet by rows
ggplot(surveys, 
       aes(x = weight, y = hindfoot_length)) +
  geom_point() +
  facet_grid(rows = vars(sex))

# One row, facet by column
ggplot(surveys, 
       aes(x = weight, y = hindfoot_length)) +
  geom_point() +
  facet_grid(cols = vars(sex))
```

<br />

## Saving a plot to a file {#saveplot}

Saving a plot is something you will want to do often. Fortunately it is quite easy to do this with `tidyverse`.

To save a plot to file we use the `ggsave` function.  If you look at the [documentation of ggsave](https://ggplot2.tidyverse.org/reference/ggsave.html) you can see the different arguments the `ggsave` function takes.  Let's save the plot present in the `surveys_plot` variable into a file called `plot_weight_hindfoot_density2d.png` and place this into the `img_output` folder within our working directory (check that it is present, if not you need to create it).  

```{r ggsave, eval=FALSE, warning=FALSE, message=FALSE}
# Save plot that you would like to save into a variable
out_plot <- surveys_plot + geom_density2d()
# Save plot to file
ggsave(filename = "img_output/plot_weight_hindfoot_density2d.png", plot = out_plot)
```

<br />

:::note
You do not necessarily need to save the plot into a variable before saving it to file.  If you do not specify the `plot` argument in the `ggsave` function, `ggsave` will take the last plot that you plotted and save it into the `filename` specified.

```{r ggsave-directly, eval=FALSE, warning=FALSE, message=FALSE}
# Save plot to file
ggsave(filename = "img_output/plot_weight_hindfoot_density2d.png")
```

Alternatively, you can go to the Plots pane and click on the **Export** button. This can be easy if you quickly want to share a plot, but it does mean that it is not reproducible. So if you want other people to recreate your work, then always use code to save your plots!
:::
